#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
using namespace std;

class sudoku {
  public:
	sudoku();

	void solve();

    void read(const char *);
    void write(const char *);
    void write(const char *, const char *);

  private:
    int solve(const vector<int>&, int num);

    // various support functions 
    bool error_check_value(int num);
    bool error_check_uniqueness();
    bool searchSudoku(int first, int last);
  vector<int> values;

    void display();

    int game[9][9];
};

sudoku::sudoku() { 
  for (int i=0; i<9; i++) {
    for (int j=0; j<9; j++)
      game[i][j] = 0;
  }
}

void sudoku::solve() {
  cout << "SOLVE\n";

  // call recursive computation

  display();
  
  // error check data values
  // error check uniqueness
  // exit if errors detected
}

void sudoku::read(const char *fname) {
  cout << "READ\n";
  bool check1 = true;
  ifstream fin(fname);
    
  int i, j, v;

  while (fin >> i >> j >> v) {
    if(!(i<9 && i>=0 && j<9 && j>=0))
    {
      cerr<<i<<" "<<j<<" "<<v<<" illegal grid index"<<endl;
      check1 = false;
    }
    // error check grid indices
    game[i][j] = v;
  }
  if(check1 == false)
  {
    exit(0);
  }

  fin.close();

  // exit if bad grid indices
 bool check =  error_check_value(0);
 if(check == true)
 {
   check = error_check_uniqueness();
   if(check == false)
   {
     exit(0);
   }
 }
 else
 {
   exit(0);
 }

  // error check data values
  //error_check_uniqueness();
  // error check uniqueness
  // exit if errors detected
}

void sudoku::write(const char *fname) {
  ofstream fout(fname);

  for (int i=0; i<9; i++) {
    for (int j=0; j<9; j++) {
      if (0 < game[i][j]) {
        fout << i << " "
			 << j << " "
		     << game[i][j] << "\n";
      }
    }
  }

  fout.close();
}

void sudoku::write(const char *fname, const char *addon) {
  int N1 = strlen(fname);
  int N2 = strlen(addon);

  char *n_fname = new char[N1+N2+2];

  // strip .txt suffix, then concatenate _addon.txt
  strncpy(n_fname, fname, N1-4);
  strcpy(n_fname+N1-4, "_");
  strcpy(n_fname+N1-3, addon);
  strcpy(n_fname+N1-3+N2, ".txt");

  write(n_fname);

  delete [] n_fname;
}

void sudoku::display() {
  cout << "| ----------------------------- |\n";
  for (int i=0; i<9; i++) {
    for (int j=0; j<9; j++) {
	  if (j%3 == 0) 
	    cout << "|";
      cout << "  " << game[i][j];
	}
    cout << "  |\n";
	if (i%3 == 2)
      cout << "| ----------------------------- |\n";
  }
}

int sudoku::solve(const vector<int>&, int num) {
  // if solution found, 
  //   return solution-found
  //
  // set cell index (i,j)
  // determine valid values 
  // if no valid values left,
  //   return road-to-nowhere
  //
  // iterate thru valid values 
  //   game[i][j] = next value
  //   if solve(arguments) == solution-found
  //     return solution-found
  //
  // reset: game[i][j] = 0
  // return road-to-nowhere
}

bool sudoku::error_check_value(int num){
bool check = true;
for(int i = 0;i<9;i++)
{
  for(int j = 0;j<9;j++)
  {
    if ((game[i][j] < 0) || (game[i][j] > 9))
    {
      cerr<<i<<" "<<j<<" "<<game[i][j]<<" illegal data value"<<endl;
      check = false;
    }
  }
}
return check;
}  

bool sudoku:: error_check_uniqueness(){
for 
  for(int i = 0;i<9;i++)
  {
    for(int j = 0;j<9;j++)
      {
	if(game[i][j] != 0)
        {
	  searchSudoku(i,j);
	}    
      }
    values.clear();
  }
for(int i = 0;i<9;i++)
  {
    for(int j = 0;j<9;j++)
      {
	if(game[j][i] != 0)
        {
	  searchSudoku(j,i);
	}    
      }
    values.clear();
  }
  
}
bool sudoku:: searchSudoku(int first, int last){
  bool check = true;
  if(std::find(values.begin(),values.end(),first)!=values.end())
    {
      check =false;
      cerr<<first<<" "<<last<<" "<<game[first][last]<<" illegal no-unique value"<<endl;
    }
  else
    {
      values.push_back(first);
    }
  return check;
}
int main(int argc, char *argv[]) {
  srand(time(NULL));

  if ((argc != 3) ||
      (strcmp(argv[1], "-s") != 0) ||
	  strstr(argv[argc-1], ".txt") == NULL) {
    cerr << "usage: Sudoku -s game.txt\n";
	exit(0);
  }

  sudoku sudoku_game;

  if (strcmp(argv[1], "-s") == 0) {
    sudoku_game.read(argv[2]);
    sudoku_game.solve();
    sudoku_game.write(argv[2], "solved");
  }
}
